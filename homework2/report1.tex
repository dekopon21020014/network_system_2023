%\documentclass[a4paper,titlepage,dvipdfmx]{jsarticle}%% プリアンブルここから
\documentclass[a4paper,dvipdfmx]{jsarticle}

\title{情報通信システム論　レポート課題} 
\author{学籍番号: 1240293 \\ 氏名: 植田蓮}
\date{\today}

\begin{document}
\maketitle
\abstract{
  この文書は2023年度の情報通信システム論レポート課題である．
  ``クライアントプログラムをC言語で作成せよ''という課題で作成したプログラムの説明，実行例，考察，感想を記述する．
}
\section{課題の要件}
作成するプログラムの要件は以下を満たすことである．

\begin{itemize}
  \item netcatツールのクライアント機能を実現する．
  \item Socket APIを用い，指定されたIPアドレスwポートのサーバーにTCPで接続する．
  \item サーバーと接続したソケット及び標準入力の2つをselect()で監視する．
  \item もし標準入力から入力があったら，その内容をサーバーへ送信する．
  \item もしサーバーからデータを受信したらそれを標準出力へ出力する
  \item どちらかがEOFになるか，エラーが発生するまで上記を繰り返す．
  \item サーバとの接続を切断して終了する
\end{itemize}

\section{プログラムの説明}
このプログラムは，実行時にコマンドライン引数としてホスト名と，ポート番号を指定する必要がある．
どちらか一方でも不足している場合にはargument errorをとしてプログラムを終了する．
また，指定できるポート番号はTCPに則り，1から65535までの整数に限定している．

指定されたサーバーの名前解決には，getaddrinfoを用いている．
getaddrinfoのhintsには，PF$\_$UNSPECを指定しているため，IPのバージョンは関係なくサーバーに接続する．
一方で，SOCK$\_$STREAMを指定しているため，UDPとTCPどちらもサービスしているようなサーバーであっても，TCPで接続を行う．
指定された，サーバーへの接続が確立できない，すなわち，socketを作成することができない場合には，例外処理を行い，プログラムを終了する．
接続が確立できた婆には，接続が確認できたソケット及び標準入力をselectによって監視する．
selectのタイムアウト時間は指定していないため，指定された記述子がブロックしない状態になるまで必ずブロックを続ける．
読み取りがブロックしない状態になった記述子があれば，その記述子からreadを行う．

サーバーとの接続ソケットからreadした場合には，読み込んだ内容を標準出力へ出力を行う．
標準入力からreadした場合には，読み込んだ内容をサーバーへと送信する．
また，どちらの記述子からreadした場合でも，読み込んだ結果のサイズが0の場合には，EOFを読み込んだとして，サーバーとの接続ソケットをcloseして，プログラムを終了する．

\section{プログラムの実行例}
高知工科大学情報学群のWebサーバへと接続を試みた例を示す．
\begin{quote}
\begin{verbatim}
------------------------------------------------
user@kut % ./a.out www.info.kochi-tech.ac.jp 80
hoge
HTTP/1.1 400 Bad Request
Date: Sun, 29 Oct 2023 03:26:56 GMT
Server: Apache
Content-Length: 226
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
</body></html>
EOF
------------------------------------------------
\end{verbatim}
\end{quote}
``hoge''というリクエストを送った結果として``Bad Request''のレスポンスが返された．
また，Webサーバ側が接続をcloseしたことによって，プログラムが終了している．

さらに，2022年度4Qのネットワーク設計で作成した，しりとりサーバーとの接続例を以下に示す．
しりとりサーバーに複数回のリクエストを送信することができていることが確認できる．
\begin{quote}
\begin{verbatim}
------------------------------------------------
user@kut % ./a.out localhost 12345            
i
current_word:i
in
current_word:in
now
current_word:now
word
current_word:word
drive
current_word:drive
eeeeee
I don't know that word
iiiiii
Terminating and initial letters do not match
^C
------------------------------------------------
\end{verbatim}
\end{quote}

\section{考察}
今回作成したプログラムではreadするためのバッファのサイズを1024に設定している．
そのため，1024バイト以上のデータのリクエストは送信することができない．
テキストだけであれば，小規模のプログラムで用いるプロトコルであれば1024バイトでも十分かもしれないが，プロトコルによってはテキストのみでも1024バイトを超える可能性は十分に考えられる．
クライアントプログラムは，エンドユーザ本人が使うものだと，限定して，大規模なデータのを受け取るか受け取らないかは，サーバ側に任せて，クライアント側のバッファサイズは十分に大きくするという手段も有効だと考えられる．
しかし，バッファサイズの設定についてはそのクライアントプログラムの利用用途を十分に考えてどの程度が適当なサイズか，十分に検討して設計すべきである．

また，今回の実装では，readについて確実にreadができているかのチェック機構を設けていない．
もし，一度でreadできなかった場合には，次のループでreadを行うようになっている．
プロトコルによっては1回のリクエストと判定されずに，エラーが起きる可能性がある．
対策としては，記述子をノンブロッキングに設定した上で，再度readを行い読み込めるデータが無いかを確認するなどがある．

\section{感想}
今回の課題を通して，C言語の構造体の強力さを感じた．
inet\_ptonではsockaddr$\_$in型の構造体をsockaddr型にキャストして渡しているが，これは，それぞれの構造体のメンバ変数をうまく並べて作っているからできている．
Javaなどのオブジェクト指向言語では継承などを用いてこれを提供しているが，C言語では継承を明示的に使わずとも，構造体の設計者が継承を意識して作るだけで実現できている．
メモリ上に何が展開されているかイメージできていればあたりまえのことだが，C言語の強力さを感じた．

また，getaddrinfoの返り値が連結リストになっているのも興味深かった．
対象のサーバが何個のサービスをしているかわからない時でも，動的にメモリを確保することで実現されており面白いと思った．
シンプルな考え方であれば，ある程度の大きさの配列を静的に用意しておいて，そこに各構造体へのポインタを格納すれば良いと考えられるが，そうではなく動的に用意されている．
連結リストは，知識としては知っているが，正直これまでまともに使ったことがなかったが，こんなところで用いられているのかと思った．
連結リストの使い方として一つ知識が増えた．

ヘッダファイルのincludeについて，少し疑問点があった．
selectのリファレンスを見ると，sys/select.hをincludeするように記述があったが，netdb.hやstdlib.hをincludeしている場合にはsys/select.hをinclude指定なくてもselectを用いることが可能であった．
このような場合にはsys/select.hは冗長なものとしてincludeに指定しないほうが良いのか，それとも明示的にincludeをしておいたほうが良いのか至らなかった．


\begin{thebibliography}{9}
\bibitem {bib:syoukai-unix}
  W.Richard Stevens(著), Stephen A. Rage(著),  大木 敦雄 (翻訳), ``詳解UNIXプログラミング 第3版'', 翔泳社，2014/4/22

\bibitem {bib:linux1}
  W.リチャード・スティーヴンス(著), 篠田陽一(訳), ``UNIXネットワークプログラミング第2版 Vol.1 ネットワークAPI:ソケットとXTI'', ピアソンエデュケーション，1998/7/30

\bibitem {bib:linux2}
 W.リチャード・スティーヴンス(著), 篠田陽一(訳), ``UNIXネットワークプログラミング第2版 Vol.2 IPC:プロセス間通信'', ピアソンエデュケーション，2004/2/2
 
\end{thebibliography}

\end{document}
